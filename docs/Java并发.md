# Java并发

### 1，并发基础

###### **1.1  thread对象的start()与run()**

创建完 thread 对象后该线程并没有被启动执行，直到调用了 start 方法后 真正启动了线程。其实调用 start 方法后线程并没有马上执行而 处于就绪状态， 这个就绪状态是指线程已经获取了除 CPU 资源外的其资源，等待获取 CPU资源后才会真正处于运行状态。一旦 run 方法执行完毕，该线程就处于终止状态

###### **1.2  sleep()与wait()**

**sleep():**当运行到sleep的时候，直接进入睡眠状态，持有锁也不释放，直接不参与CPU调度，sleep时间到了之后。进入就绪状态，重新争抢CPU调度

**wait():**运行到wait时，持有锁时会释放锁，等到相同变量上有调用notify()或者notifyAll()方法时，才会重新进入就绪状态，就行CPU的调度争夺

### 2，并发其他基础

###### **2.1 实际实现中线程的工作内存**

![image-20201123102056393](https://github.com/aqiang0/learningnotes/docs/Java并发.assets/image-20201123102056393.png)

当一个线程操作共享变量时，它首先从主存复制共享变量到自己的工作内存，然后对工作内存里变量进行处理，处理完后将变量值更新到主存。

###### 2.2 共享变量内存不可见问题产生原因

![image-20201123103742293](D:\install\Typora\文档\Java并发.assets\image-20201123103742293.png)

###### 2.3 synchronized 的内存语义

![image-20201123104720116](B:\learningnote\docs\Java并发.assets\image-20201123104720116.png)

**独占锁是一种悲观锁，synchronized就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁用到的机制就是CAS，Compare and Swap。**

###### 2.4 volatile关键字

![image-20201123110259027](D:\install\Typora\文档\Java并发.assets\image-20201123110259027.png)

![image-20201123110421010](D:\install\Typora\文档\Java并发.assets\image-20201123110421010.png)



###### 2.5  CAS操作

![1213](D:\install\Typora\文档\Java并发.assets\1213.png)



###### 2.6 Java 指令重排序

在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：

**编译器优化的重排序**
编译器在不改变单线程程序语义的前提下（代码中不包含synchronized关键字），可以重新安排语句的执行顺序。

**指令级并行的重排序**
现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。

**内存系统的重排序。**
由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。 

**写volatile 变量时，可以确保 volatile 写之前的操作不会被编译器重排序到 volatile写之后。读volatile变量时，可以确保 volatile 读之后的操作不会被编译器重排序到 volatile读之前**

###### 2.7 乐观锁与悲观锁

**悲观锁**

![image-20201123151303108](D:\install\Typora\文档\Java并发.assets\image-20201123151303108.png)

**乐观锁**

![image-20201123151418777](D:\install\Typora\文档\Java并发.assets\image-20201123151418777.png)

###### 2..8 公平锁与非公平锁

![image-20201123151624626](D:\install\Typora\文档\Java并发.assets\image-20201123151624626.png)

###### 2.9 重入锁

![image-20201123153546805](D:\install\Typora\文档\Java并发.assets\image-20201123153546805.png)

**实际上， synchronize 内部锁是可重入锁， 可重入锁的原理是在锁内部维护 一个线程标示，用来标示该锁目前被哪个线程占用，然后关联 一个计数器。一开始计数器值为0，说明该锁没有被任何线程占用，当一个钱程获取了该锁时，计数器的值会变成1，这时他线程再来获取该锁时会发现锁的*<u>所有者不是自己</u>*而被阻塞挂起。**

**但是当获取了该锁的线程再次获取锁时发现锁拥有者是自己，就会把计数器值加＋1,当释放锁后计数器值-1，当计数器值为0时，锁里面的线程标示被重置为 null 这时候被阻塞的线程会被唤醒来竞争获取该锁。**

###### 2.10 自旋锁

由于 Java 中的线程是与操作系统中的线程一一对应的，所以当一个线程在获取锁（比如独占锁）失败后，会被切换到内核状态而被挂起 当该线程获取到锁时又需要将其切换到内核状态而唤醒该线程，而从用户状态切换到内核状态的开销是比较大的，在一定程度上会影响并发性能。

自旋锁则是，当前线程在获取锁时，如果发现锁已经被其他线程占有，它不马上阻塞自己，在不放弃 CPU 使用权的情况下，多次尝试获取（默认次数是 10 ，可以使用 XX PreB lockS pin 数设置该值），很有可能在后面几次尝试中其他线程己经释放了锁，如果尝试指定的次数后仍没有获取到锁，则当前线程才会被阻塞挂起，由此看来自旋锁是使用CPU时间换取线程阻塞与调度的开销，但是很有可能这些 CPU时间白白浪费了。

### 3， 并发包中ThreadLocalRandom原理剖析

