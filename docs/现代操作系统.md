# 现代操作系统



### 2 进程与线程

#### 2.1 进程

##### 2.1.1 进程模型

![image-20201130154226317](D:\install\Typora\文档\现代操作系统.assets\image-20201130154226317.png)

**单一CPU的系统中，任何一个给定的瞬间仅有一个进程真正的再运行**

##### 2.1.2 进程的3种状态

![image-20201130154852587](D:\install\Typora\文档\现代操作系统.assets\image-20201130154852587.png)

##### 2.1.3 进程表

![image-20201130155023879](D:\install\Typora\文档\现代操作系统.assets\image-20201130155023879.png)

##### 2.1.4 中断发生时底层操作系统的工作步骤

![image-20201130155237401](D:\install\Typora\文档\现代操作系统.assets\image-20201130155237401.png)

#### 2.2 线程

##### 2.2.1 线程定义

**相当于迷你进程，有自己的程序计数器，寄存器和堆栈**

![image-20201130160155914](D:\install\Typora\文档\现代操作系统.assets\image-20201130160155914.png)

![image-20201130160212545](D:\install\Typora\文档\现代操作系统.assets\image-20201130160212545.png)

#### 2.3 进程间通信

**前置知识点：**

​	原语：所谓原语，一般是指由若干条指令组成的程序段，用来实现某个特定功能，在执行过程中不可被中断。在[操作系统](https://baike.baidu.com/item/操作系统/192)中，某些被进程调用的操作，如队列操作、对信号量的操作、检查启动外设操作等，一旦开始执行，就不能被中断，否则就会出现操作错误，造成系统混乱。所以，这些操作都要用原语来实现 原语是操作系统核心（不是由进程，而是由一组程序模块组成）的一个组成部分，并且常驻内存，通常在管态下执行。原语一旦开始执行，就要连续执行完，不允许中断

##### 2.3.1 竞争条件

两个或者多个线程读取某些共享数据，而最好的结果取决于进程运行的精确时序，称为**竞争条件。**

##### 2.3.2 临界区

**互斥**

![image-20201202100419368](D:\install\Typora\文档\现代操作系统.assets\image-20201202100419368.png)

**临界区**

把对共享内存进行访问的程序片段称作**临界区。**

**避免竞争条件满足的4个要求**

![image-20201202101124155](D:\install\Typora\文档\现代操作系统.assets\image-20201202101124155.png)

##### 2.3.3 忙等待的互斥

几种实现互斥的方案：

###### 屏蔽中断

**实现方法：**

![image-20201202102845768](D:\install\Typora\文档\现代操作系统.assets\image-20201202102845768.png)

**缺点**

- 屏蔽中断权利交给用户不明智，如果没有打开，整个系统将会终止。
- 在一个多核系统中，屏蔽一个CPU的中断，不会影响其他CPU的运行

###### **锁变量**

**实现方法**

![image-20201202105413298](D:\install\Typora\文档\现代操作系统.assets\image-20201202105413298.png)

**缺点**

![image-20201202105504993](D:\install\Typora\文档\现代操作系统.assets\image-20201202105504993.png)

###### **严格轮换法**

**实现方法**

![image-20201202110645137](D:\install\Typora\文档\现代操作系统.assets\image-20201202110645137.png)

**缺点**

![image-20201202110822956](D:\install\Typora\文档\现代操作系统.assets\image-20201202110822956.png)

###### **Peterson解法**

**实现方法**

![image-20201202115742656](D:\install\Typora\文档\现代操作系统.assets\image-20201202115742656.png)

**说明：**在上面的算法中由于内部循环会导致浪费。任何一个进程要想进入临界区，首先执行函数`enter_region(i)`，其中参数是进程号，如果运行完这个函数，则进入临界区，否则在函数内部等待。`turn`是一个共享的变量，如果两个进程都想进临界区，那么`turn`的值是后面进程的，于是`while`循环条件不成立，则先给`turn`赋值的进程先进临界区。

###### **TS L指令**

**实现方法**

![image-20201202153508379](D:\install\Typora\文档\现代操作系统.assets\image-20201202153508379.png)

![image-20201202153636287](D:\install\Typora\文档\现代操作系统.assets\image-20201202153636287.png)

![image-20201202160828243](D:\install\Typora\文档\现代操作系统.assets\image-20201202160828243.png)

##### 2.3.4 睡眠与唤醒

###### **优先级反转**

![image-20201202161303700](D:\install\Typora\文档\现代操作系统.assets\image-20201202161303700.png)

###### sleep与wakeup

**实现方法**：

![image-20201202165437215](D:\install\Typora\文档\现代操作系统.assets\image-20201202165437215.png)

**缺点**：

会产生wakeup信号丢失。在生产者与消费者的问题中，会有如下情况，是的wakeup信号丢失，使两个进程一起睡眠。

![image-20201202170548242](D:\install\Typora\文档\现代操作系统.assets\image-20201202170548242.png)

**唤醒等待位**

![image-20201202171405986](D:\install\Typora\文档\现代操作系统.assets\image-20201202171405986.png)

###### 信号量

![image-20201202172845294](D:\install\Typora\文档\现代操作系统.assets\image-20201202172845294.png)

**实现方法**

![image-20201202173605403](D:\install\Typora\文档\现代操作系统.assets\image-20201202173605403.png)

**信号量原子操作的实现**

![image-20201202173927383](D:\install\Typora\文档\现代操作系统.assets\image-20201202173927383.png)



###### 互斥量

![image-20201202180819997](D:\install\Typora\文档\现代操作系统.assets\image-20201202180819997.png)

**实现方法**

![image-20201202180929644](D:\install\Typora\文档\现代操作系统.assets\image-20201202180929644.png)

**enter_region与mutex_lock的区别：**

![image-20201202181300459](D:\install\Typora\文档\现代操作系统.assets\image-20201202181300459.png)

###### 管程

**概念：**是一种程序结构，结构内的多个子程序（对象或模块）形成的多个工作线程互斥访问共享资源。这些共享资源一般是硬件设备或一群变量。管程实现了在一个时间点，最多只有一个线程在执行管程的某个子程序。

管程作为一个软件模块，封装了互斥锁以及信号量的同步操作，实现很大程度上简化了程序设计。

在管程中的线程可以临时放弃管程的互斥访问，让其他线程进入到管程中来。

**管程是一种高级的同步原语**。任意时刻管程中只能有一个活跃进程。它**是一种编程语言的组件**，所以编译器知道它们很特殊，并可以采用与其他过程调用不同的方法来处理它们。典型地，**当一个进程调用管程中的过程，前几条指令将检查在管程中是否有其他的活跃进程。如果有，调用进程将挂起，直到另一个进程离开管程。如果没有，则调用进程便进入管程。**

**对管程的实现互斥由编译器负责！在Java中，只要将关键字synchronized加入到方法声明中，Java保证一旦某个线程执行该方法，就不允许其他线程执行该方法，就不允许其他线程执行该类中的任何其他方法。**